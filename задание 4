#include <Wire.h>
#include <LiquidCrystal_I2C.h>

LiquidCrystal_I2C lcd(0x27, 16, 2);

// Клавиатура
const int rowPins[4] = {7, 6, 5, 4};
const int colPins[4] = {11, 10, 9, 8};

char keys[4][4] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};

// Переменные
volatile unsigned long timerCount = 0;
volatile bool updateDisplay = false;
volatile char pressedKey = 0;
volatile unsigned long lastKeyTime = 0;

void setup() {
  Serial.begin(9600);
  lcd.init();
  lcd.backlight();

  Serial.println("=== СИСТЕМА LCD + КЛАВИАТУРА ===");
  Serial.println("Инициализация...");
  
  // Настройка пинов клавиатуры
  for (int i = 0; i < 4; i++) {
    pinMode(rowPins[i], OUTPUT);
    digitalWrite(rowPins[i], HIGH);
    Serial.print("Строка D");
    Serial.print(rowPins[i]);
    Serial.println(" - OUTPUT");
  }
  for (int i = 0; i < 4; i++) {
    pinMode(colPins[i], INPUT_PULLUP);
    Serial.print("Столбец D");
    Serial.print(colPins[i]);
    Serial.println(" - INPUT_PULLUP");
  }

  // Настройка Timer1 для обновления LCD (1 Гц)
  noInterrupts();
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1 = 0;
  OCR1A = 15624; // 1 Гц
  TCCR1B |= (1 << WGM12);
  TCCR1B |= (1 << CS12) | (1 << CS10);
  TIMSK1 |= (1 << OCIE1A);
  interrupts();

  // Настройка Timer2 для сканирования клавиатуры (100 Гц)
  TCCR2A = 0;
  TCCR2B = 0;
  TCNT2 = 0;
  OCR2A = 155; // 100 Гц
  TCCR2A |= (1 << WGM21);
  TCCR2B |= (1 << CS22) | (1 << CS21);
  TIMSK2 |= (1 << OCIE2A);

  // Инициализация дисплея
  lcd.setCursor(0, 0);
  lcd.print("Timer: 0");
  lcd.setCursor(0, 1);
  lcd.print("Key: None");

  Serial.println("Система готова!");
  Serial.println("Timer1: 1 Гц - обновление LCD");
  Serial.println("Timer2: 100 Гц - сканирование клавиатуры");
  Serial.println("Нажимайте клавиши!");
  Serial.println("-----------------------------------");
}

// Прерывание Timer1 - обновление LCD (1 Гц)
ISR(TIMER1_COMPA_vect) {
  timerCount++;
  updateDisplay = true;
}

// Прерывание Timer2 - сканирование клавиатуры (100 Гц)
ISR(TIMER2_COMPA_vect) {
  static byte currentRow = 0;
  
  // Деактивируем предыдущую строку
  digitalWrite(rowPins[currentRow], HIGH);
  
  // Переходим к следующей строке
  currentRow = (currentRow + 1) % 4;
  
  // Активируем новую строку
  digitalWrite(rowPins[currentRow], LOW);
  
  // Сканируем столбцы
  for (int col = 0; col < 4; col++) {
    if (digitalRead(colPins[col]) == LOW) {
      // Антидребезг
      if (millis() - lastKeyTime > 200) {
        pressedKey = keys[currentRow][col];
        lastKeyTime = millis();
      }
    }
  }
}

void loop() {
  static unsigned long lastDisplayTime = 0;
  static char lastKey = 0;
  
  // 1. ОБНОВЛЕНИЕ LCD ПО ТАЙМЕРУ
  if (updateDisplay) {
    lcd.setCursor(0, 0);
    lcd.print("Timer: ");
    lcd.print(timerCount);
    lcd.print("  ");
    
    Serial.print("LCD Обновление: ");
    Serial.println(timerCount);
    
    updateDisplay = false;
    lastDisplayTime = millis();
  }
  
  // 2. ОБРАБОТКА НАЖАТЫХ КЛАВИШ
  if (pressedKey != 0 && pressedKey != lastKey) {
    // Обновление LCD
    lcd.setCursor(0, 1);
    lcd.print("Key: ");
    lcd.print(pressedKey);
    lcd.print("    ");
    
    // Вывод в Serial
    Serial.print("KEY Нажата: '");
    Serial.print(pressedKey);
    Serial.print("' | Время: ");
    Serial.println(millis());
    
    // Специальные действия
    if (pressedKey == 'A') {
      timerCount = 0;
      Serial.println("ACTION Сброс счетчика!");
      lcd.setCursor(0, 0);
      lcd.print("Timer: 0    ");
    }
    
    lastKey = pressedKey;
    pressedKey = 0;
  }
  
  // 3. СБРОС ОТОБРАЖЕНИЯ КЛАВИШИ ЧЕРЕЗ 3 СЕКУНДЫ
  if (lastKey != 0 && (millis() - lastKeyTime > 3000)) {
    lcd.setCursor(0, 1);
    lcd.print("Key: None    ");
    lastKey = 0;
    Serial.println("KEY Сброс отображения");
    }
  
  // 4. ПЕРИОДИЧЕСКАЯ СТАТИСТИКА
  static unsigned long lastStatTime = 0;
  if (millis() - lastStatTime >= 10000) {
    Serial.println("=== СТАТИСТИКА ===");
    Serial.print("Время: ");
    Serial.print(millis() / 1000);
    Serial.print("с | Таймер: ");
    Serial.println(timerCount);
    Serial.println("==================");
    lastStatTime = millis();
  }
}
