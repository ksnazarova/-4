// Матричная клавиатура 4x4
const int rowPins[4] = {7, 6, 5, 4};    // Строки (Rows)
const int colPins[4] = {11, 10, 9, 8};  // Столбцы (Columns)

// Раскладка клавиатуры
char keys[4][4] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};

// Переменные для прерываний
volatile byte currentRow = 0;
volatile char pressedKey = 0;
volatile unsigned long lastKeyTime = 0;
volatile int scanCounter = 0;
volatile bool newKeyPressed = false;

// Глобальные переменные для статистики
unsigned long lastScanCount = 0;
unsigned long lastStatusTime = 0;

void setup() {
  Serial.begin(9600);
  Serial.println("=== СИСТЕМА СКАНИРОВАНИЯ КЛАВИАТУРЫ ===");
  Serial.println("Инициализация...");
  
  // Настройка пинов клавиатуры
  for (int i = 0; i < 4; i++) {
    pinMode(rowPins[i], OUTPUT);
    digitalWrite(rowPins[i], HIGH); // Все строки отключены (HIGH)
    Serial.print("Строка D");
    Serial.print(rowPins[i]);
    Serial.println(" - OUTPUT, HIGH");
  }
  
  for (int i = 0; i < 4; i++) {
    pinMode(colPins[i], INPUT_PULLUP);
    Serial.print("Столбец D");
    Serial.print(colPins[i]);
    Serial.println(" - INPUT_PULLUP");
  }
  
  // Настройка Timer1 для прерываний 1 кГц (1 мс)
  setupTimer1();
  
  Serial.println("----------------------------------------");
  Serial.println("Timer1 настроен на 1000 Гц (1 мс)");
  Serial.println("Система готова. Нажимайте клавиши:");
  Serial.println(" 1 2 3 A");
  Serial.println(" 4 5 6 B"); 
  Serial.println(" 7 8 9 C");
  Serial.println(" * 0 # D");
  Serial.println("----------------------------------------");
}

void setupTimer1() {
  // Отключаем прерывания на время настройки
  noInterrupts();
  
  // Сбрасываем регистры таймера
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1 = 0;
  
  // Устанавливаем регистр сравнения для 1 кГц (1 мс)
  // Расчет: 16,000,000 / 8 / 2000 = 1000 Гц
  OCR1A = 1999; // 2000 - 1 = 1999
  
  // Включаем режим CTC (Clear Timer on Compare)
  TCCR1B |= (1 << WGM12);
  
  // Устанавливаем предделитель 8
  TCCR1B |= (1 << CS11);
  
  // Включаем прерывание по совпадению
  TIMSK1 |= (1 << OCIE1A);
  
  // Включаем прерывания
  interrupts();
}

// Обработчик прерывания Timer1
ISR(TIMER1_COMPA_vect) {
  // 1. Деактивируем текущую строку
  digitalWrite(rowPins[currentRow], HIGH);
  
  // 2. Переходим к следующей строке
  currentRow = (currentRow + 1) % 4;
  
  // 3. Активируем новую строку (подаем LOW)
  digitalWrite(rowPins[currentRow], LOW);
  
  // 4. Сканируем столбцы текущей строки
  for (int col = 0; col < 4; col++) {
    // Если столбец LOW - клавиша нажата
    if (digitalRead(colPins[col]) == LOW) {
      // Проверяем антидребезг (минимум 200 мс между нажатиями)
      if (millis() - lastKeyTime > 200) {
        pressedKey = keys[currentRow][col];
        newKeyPressed = true;
        lastKeyTime = millis();
      }
    }
  }
  
  // Увеличиваем счетчик сканирований
  scanCounter++;
}

void loop() {
  // Обработка нажатой клавиши
  if (newKeyPressed && pressedKey != 0) {
    printKeyInfo();
    newKeyPressed = false;
  }
  
  // Вывод статистики каждые 5 секунд
  if (millis() - lastStatusTime >= 5000) {
    printStatistics();
    lastStatusTime = millis();
    lastScanCount = scanCounter;
  }
}

void printKeyInfo() {
  Serial.print(">>> КЛАВИША: '");
  Serial.print(pressedKey);
  Serial.print("' | Строка: ");
  Serial.print(currentRow);
  Serial.print(" | Время: ");
  Serial.print(millis());
  Serial.print(" мс");
  Serial.println();
  
  // Сбрасываем клавишу после обработки
  pressedKey = 0;
}

void printStatistics() {
  unsigned long scansPerSecond = (scanCounter - lastScanCount) / 5;
  
  Serial.println("----------------------------------------");
  Serial.print("СТАТИСТИКА | Время: ");
  Serial.print(millis() / 1000);
  Serial.print(" с");
  Serial.print(" | Сканирований: ");
  Serial.print(scanCounter);
  Serial.print(" (");
  Serial.print(scansPerSecond);
  Serial.println("/сек)");
  Serial.print("Текущая строка: ");
  Serial.println(currentRow);
  Serial.println("----------------------------------------");
}
